<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ThreeJS - Fluid Shader on GLB Texture</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
<canvas class="webgl"></canvas>
<script type="module">
    import * as THREE from 'three';
    import vertexShader from './shaders/abduction-of-europa/vertex.glsl';
    import fboShader from './shaders/abduction-of-europa/fbo.glsl';
    import finalFragmentShader from './shaders/abduction-of-europa/image.glsl';
    import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    const canvas = document.querySelector('canvas.webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const sizes = { width: window.innerWidth, height: window.innerHeight };
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
    camera.position.z = 3;

    const finalScene = new THREE.Scene();

    const whiteScene = new THREE.Scene();
    const whiteBg = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    whiteScene.add(whiteBg);

    const clock = new THREE.Clock();
    const planeSize = 2;
    const interactiveMeshes = [];
    const planes = [];

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(-10, -10);

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('/examples/jsm/libs/draco/');
    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);

    gltfLoader.load(
            './textures/abduction_of_europa/abducation_of_europea.glb',
            (gltf) => {
                const model = gltf.scene;
                let texture;

                model.traverse((child) => {
                    if (child.isMesh && child.material.name === "women.001") {
                        console.log(child.material)
                        texture = child.material.map;
                    }
                });



                const sourceScene = new THREE.Scene();
                const dummy = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 16, 16),
                        new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                dummy.name = 'interactionDummy';
                dummy.position.set(10000, 10000, 10000);
                sourceScene.add(dummy);

                const renderTarget = new THREE.WebGLRenderTarget(sizes.width, sizes.height);
                let trailTargetA = new THREE.WebGLRenderTarget(sizes.width, sizes.height);
                let trailTargetB = new THREE.WebGLRenderTarget(sizes.width, sizes.height);
                const whiteTarget = new THREE.WebGLRenderTarget(sizes.width, sizes.height);

                const orthoSourceCamera = new THREE.OrthographicCamera(
                        -planeSize / 2, planeSize / 2,
                        planeSize / 2, -planeSize / 2,
                        0.1, 100
                );
                orthoSourceCamera.position.set(0, 0, 1);
                orthoSourceCamera.lookAt(0, 0, 0);

                const fboScene = new THREE.Scene();
                const fboCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const fboMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: null },
                        tPrev: { value: null },
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector4(sizes.width, sizes.height, 1 / sizes.width, 1 / sizes.height) },
                    },
                    vertexShader,
                    fragmentShader: fboShader
                });
                const fboQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), fboMaterial);
                fboScene.add(fboQuad);

                const finalMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tReveal: { value: null },
                        tColor: { value: texture },
                    },
                    vertexShader,
                    fragmentShader: finalFragmentShader,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const finalQuad = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), finalMaterial);
                finalScene.add(finalQuad);
                interactiveMeshes.push(finalQuad);

                planes.push({
                    sourceScene,
                    dummy,
                    orthoSourceCamera,
                    fboScene,
                    fboCamera,
                    fboMaterial,
                    finalMaterial,
                    trailTargetA,
                    trailTargetB,
                    whiteTarget,
                    renderTarget,
                    finalQuad
                });

                const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const plane = planes[0];
                renderer.setRenderTarget(plane.trailTargetB);
                renderer.render(whiteScene, initCamera);
                renderer.setRenderTarget(plane.trailTargetA);
                renderer.render(whiteScene, initCamera);
                renderer.setRenderTarget(plane.whiteTarget);
                renderer.render(whiteScene, initCamera);
                plane.fboMaterial.uniforms.tPrev.value = plane.trailTargetB.texture;
                plane.finalMaterial.uniforms.tReveal.value = plane.trailTargetA.texture;
                renderer.setRenderTarget(null);

                tick();
            },
    );

    function onPointerMove( event ) {
        pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes);

        if (planes.length > 0) {
            const planeData = planes[0];
            planeData.dummy.position.set(10000, 10000, 10000);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const uv = intersection.uv;
                planeData.dummy.position.x = (uv.x - 0.5) * planeSize;
                planeData.dummy.position.y = (uv.y - 0.5) * planeSize;
                planeData.dummy.position.z = 0;
            }
        }
    }
    window.addEventListener('pointermove', onPointerMove);

    function tick() {
        const elapsedTime = clock.getElapsedTime();

        if (planes.length > 0) {
            const plane = planes[0];

            renderer.setRenderTarget(plane.renderTarget);
            renderer.render(plane.sourceScene, plane.orthoSourceCamera);

            plane.fboMaterial.uniforms.tDiffuse.value = plane.renderTarget.texture;
            plane.fboMaterial.uniforms.tPrev.value = plane.trailTargetB.texture;
            plane.fboMaterial.uniforms.time.value = elapsedTime;
            renderer.setRenderTarget(plane.trailTargetA);
            renderer.render(plane.fboScene, plane.fboCamera);

            plane.finalMaterial.uniforms.tReveal.value = plane.trailTargetA.texture;

            const temp = plane.trailTargetA;
            plane.trailTargetA = plane.trailTargetB;
            plane.trailTargetB = temp;
        }

        renderer.setRenderTarget(null);
        renderer.render(finalScene, camera);

        requestAnimationFrame(tick);
    }

    window.addEventListener('resize', () => {
        sizes.width = window.innerWidth;
        sizes.height = window.innerHeight;

        camera.aspect = sizes.width / sizes.height;
        camera.updateProjectionMatrix();

        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        if (planes.length > 0) {
            const plane = planes[0];
            plane.renderTarget.setSize(sizes.width, sizes.height);
            plane.trailTargetA.setSize(sizes.width, sizes.height);
            plane.trailTargetB.setSize(sizes.width, sizes.height);
            plane.whiteTarget.setSize(sizes.width, sizes.height);

            plane.fboMaterial.uniforms.resolution.value.x = sizes.width;
            plane.fboMaterial.uniforms.resolution.value.y = sizes.height;
            plane.fboMaterial.uniforms.resolution.value.z = 1 / sizes.width;
            plane.fboMaterial.uniforms.resolution.value.w = 1 / sizes.height;

            const initCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            renderer.setRenderTarget(plane.trailTargetB);
            renderer.render(whiteScene, initCamera);
            renderer.setRenderTarget(plane.trailTargetA);
            renderer.render(whiteScene, initCamera);
            renderer.setRenderTarget(plane.whiteTarget);
            renderer.render(whiteScene, initCamera);
            plane.fboMaterial.uniforms.tPrev.value = plane.trailTargetB.texture;
            plane.finalMaterial.uniforms.tReveal.value = plane.trailTargetA.texture;
            renderer.setRenderTarget(null);
        }
    });
</script>
</body>
</html>
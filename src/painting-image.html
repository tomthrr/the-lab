<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta
      name="viewport"
      content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
  />

  <title>ThreeJS - Watercolor effect</title>
  <link href="assets/main.scss" rel="stylesheet" />
</head>
<body class="container-project">
<div class="container"></div>
<canvas class="webgl"></canvas>
<script type="module">
  import * as THREE from 'three'
  import GUI from 'lil-gui'
  import vertexShader from './shaders/painting-image/vertex.glsl'
  import fragmentShader from './shaders/painting-image/fragment.glsl'
  import fboShader from './shaders/painting-image/fbo.glsl'
  import finalFragmentShader from './shaders/painting-image/image.glsl'

  /**
   Comment ca marche ?
   - On a plusieurs scènes, on rends la scène de base avec le cercle qui suit notre souris
   - On rends la scène blanche avec le plan verre
   - On rends le shader fbo (watercolor)
   - on rends l'image finale

   on ajoute a ca un effet ping pong, qui va permettre de se baser sur les frames
   précédentes et garder cet effet trail, qui permet de créer des trainées.
   */
  const canvas = document.querySelector('canvas.webgl');

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f0f0f);

  const whiteScene = new THREE.Scene();
  const whitebg = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshBasicMaterial({color: 0xffffff})
  );

  whiteScene.add(whitebg);
  whitebg.position.z = -1;



  /*
    *  Textures
    */
  const geometry = new THREE.PlaneGeometry( 10, 10 );
  const material = new THREE.MeshBasicMaterial( {color: 0x000000} );
  const cube = new THREE.Mesh( geometry, material );
  scene.add( cube );

  const textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load('/textures/particles-wave/ball.png')

  const dummy = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 32, 32),
    new THREE.MeshBasicMaterial({
      color: 0xffffff,
      // map: texture,
      // transparent: true,
      // alphaMap: texture,
      // depthWrite: false,
      // blending: THREE.AdditiveBlending
    })
  );
  scene.add( dummy );

  /**
   * Mouse Events
   */

  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  function onPointerMove( event ) {
    // calculate pointer position in normalized device coordinates
    // (-1 to +1) for both components
    pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    raycaster.setFromCamera(pointer, camera);
    const intersects = raycaster.intersectObjects([cube])
    if (intersects.length > 0) {
      dummy.position.copy(intersects[0].point);
    }
  }


  /**
   * Sizes
   */
  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
  }

  window.addEventListener('resize', () => {
    //updates sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

    // Update render targets
    sourceTarget.setSize(sizes.width, sizes.height)
    targetA.setSize(sizes.width, sizes.height)
    targetB.setSize(sizes.width, sizes.height)
    whiteTarget.setSize(sizes.width, sizes.height)

    // Update resolution uniform
    fboMaterial.uniforms.resolution.value.set(sizes.width, sizes.height, 1, 1)
  })

  /**
   * Pipeline
   */
    // scene for calculation/pingponging
  const sourceTarget = new THREE.WebGLRenderTarget(sizes.width, sizes.height);

  let targetA = new THREE.WebGLRenderTarget(sizes.width, sizes.height);
  let targetB = new THREE.WebGLRenderTarget(sizes.width, sizes.height);

  // white target for the first render
  const whiteTarget = new THREE.WebGLRenderTarget(sizes.width, sizes.height);

  const fboScene = new THREE.Scene();
  const fboCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

  /**
   * Debug Parameters
   */
  const debugParams = {
    noiseScale: 20.0,
    dispStrength: 0.003,
    bleedIntensity: 0.3,
    fadeRate: 1.005,
    fadeOffset: 0.002,
    brushSize: 0.1,
    clearCanvas: () => {
      renderer.setRenderTarget(targetA);
      renderer.render(whiteScene, camera);
      renderer.setRenderTarget(targetB);
      renderer.render(whiteScene, camera);
      renderer.setRenderTarget(null);
    }
  };

  const fboMaterial = new THREE.ShaderMaterial({
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 },
      tPrev: { value: whiteTarget.texture },
      resolution: { value: new THREE.Vector4(sizes.width, sizes.height, 1, 1) },
      noiseScale: { value: debugParams.noiseScale },
      dispStrength: { value: debugParams.dispStrength },
      bleedIntensity: { value: debugParams.bleedIntensity },
      fadeRate: { value: debugParams.fadeRate },
      fadeOffset: { value: debugParams.fadeOffset },
    },
    vertexShader,
    fragmentShader: fboShader
  });

  const fboQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), fboMaterial);
  fboScene.add(fboQuad);

  //final render target to output texture
  const finalScene = new THREE.Scene();

  /**
   * Image
   */
  const image = new THREE.TextureLoader().load("/corgi.jpg");
  const finalMaterial = new THREE.ShaderMaterial({
    uniforms: {
      tReveal: { value: null },
      tColor: { value: image },
    },
    vertexShader,
    fragmentShader: finalFragmentShader,
  });

  const finalQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), finalMaterial);
  finalScene.add(finalQuad);

  /**
   * Camera
   */
    // Base camera
  const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
  camera.position.x = 0
  camera.position.y = 0
  camera.position.z = 2
  scene.add(camera)

  /**
   * Renderer
   */
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
  })
  renderer.setSize(sizes.width, sizes.height)
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

  /**
   * Debug GUI
   */
  const gui = new GUI();
  
  const watercolorFolder = gui.addFolder('Watercolor Effect');
  watercolorFolder.add(debugParams, 'noiseScale', 1, 50, 0.1).name('Noise Scale').onChange((v) => {
    fboMaterial.uniforms.noiseScale.value = v;
  });
  watercolorFolder.add(debugParams, 'dispStrength', 0.001, 0.02, 0.0001).name('Displacement').onChange((v) => {
    fboMaterial.uniforms.dispStrength.value = v;
  });
  watercolorFolder.add(debugParams, 'bleedIntensity', 0.0, 1.0, 0.01).name('Bleed Intensity').onChange((v) => {
    fboMaterial.uniforms.bleedIntensity.value = v;
  });
  watercolorFolder.add(debugParams, 'fadeRate', 1.0, 1.02, 0.0001).name('Fade Rate').onChange((v) => {
    fboMaterial.uniforms.fadeRate.value = v;
  });
  watercolorFolder.add(debugParams, 'fadeOffset', 0.0, 0.01, 0.0001).name('Fade Offset').onChange((v) => {
    fboMaterial.uniforms.fadeOffset.value = v;
  });
  
  const brushFolder = gui.addFolder('Brush');
  brushFolder.add(debugParams, 'brushSize', 0.02, 0.5, 0.01).name('Brush Size').onChange((v) => {
    dummy.geometry.dispose();
    dummy.geometry = new THREE.SphereGeometry(v, 32, 32);
  });
  brushFolder.add(debugParams, 'clearCanvas').name('Clear Canvas');

  window.addEventListener('mousemove', onPointerMove);

  /**
   * Initialize ping-pong buffers with white
   */
  renderer.setRenderTarget(targetA);
  renderer.render(whiteScene, camera);
  renderer.setRenderTarget(targetB);
  renderer.render(whiteScene, camera);
  renderer.setRenderTarget(null);

  /**
   * Animate
   */
  const clock = new THREE.Clock()

  const tick = () =>
  {
    const elapsedTime = clock.getElapsedTime()

    // Render the source scene (sphere following mouse)
    renderer.setRenderTarget(sourceTarget);
    renderer.render(scene, camera)

    // Update FBO uniforms
    fboMaterial.uniforms.tDiffuse.value = sourceTarget.texture;
    fboMaterial.uniforms.tPrev.value = targetA.texture;
    fboMaterial.uniforms.time.value = elapsedTime;

    // Render watercolor effect to targetB
    renderer.setRenderTarget(targetB);
    renderer.render(fboScene, fboCamera);

    // Final output with revealed image
    finalMaterial.uniforms.tReveal.value = targetB.texture;
    renderer.setRenderTarget(null);
    renderer.render(finalScene, fboCamera);

    // Swap buffers for next frame
    const temp = targetA;
    targetA = targetB;
    targetB = temp;

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
  }

  tick()
</script>
</body>
</html>